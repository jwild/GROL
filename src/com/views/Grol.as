/*********************************************(GROL) Gladiators: Rise of Legends - Grol.asThis is the main controller of the app, handles switching of screens*********************************************/package com.views {		import flash.display.MovieClip;	import com.models.Model;	import com.utils.CustomEvent;	import flash.events.Event;		import flash.display.DisplayObject;	import flash.events.MouseEvent;	import flash.events.TransformGestureEvent;	import flash.geom.Point;	import flash.ui.Multitouch;	import flash.ui.MultitouchInputMode;	import flash.utils.getTimer;	import com.controllers.*;		public class Grol extends MovieClip{				private var m:Model = Model.instance;				//private var armory:Armory = new Armory();		//private var training:Training = new Training();		private var t:DisplayObject;		private var _scroll:Boolean = false;    	private var _prevY:Number;    	private var _dragging:Boolean = false;    	private var _lastMouseEvent:int;    	private static const MIN_DRAG_TIME:Number = 150;						public function Grol() {			trace("Grol Class Loaded");			//this listener tells us when all the screens loaded.			addEventListener(Model.CLASS_START_LOADED, gameLoaded);			m.addEventListener(CustomEvent.CHANGE_SCREEN, changeScreen);		}				public function gameLoaded(e:Event):void{			//do if statement using the LSO to see what screen should first appear. If no LSO then Class Selection Screen			var lso:Boolean = false;			if(!lso){				//screen_class_selection.visible = true;				//m.gotoScreen = "homeScreen";				addEventListener(CustomEvent.LOAD_GLADIATOR_CLASS, loadGladiatorClass);			}			loading_mc.visible = false;						setupScrolling();		}		public function loadGladiatorClass(event:CustomEvent):void{			trace("changeClass: "+event.dataObj);		}				public function changeScreen(event:CustomEvent):void{			m.currentScreen = event.dataObj;			trace("CHANGE SCREEN CALLED "+m.currentScreen);			screen_opening.visible = false;			screen_name_selection.visible = false;			screen_class_selection.visible = false;			screen_introduction.visible = false;			screen_first_quest.visible = false;			screen_home.visible = false;			screen_training.visible = false;			screen_armory_weapons.visible = false;			screen_armory_armor.visible = false;			screen_arena.visible = false;			screen_collegium.visible = false;			screen_followers.visible = false;			screen_coffers.visible = false;			screen_medic.visible = false;			screen_emporer.visible = false;			screen_profile_stat.visible = false;			screen_profile_equip.visible = false;			screen_profile_comments.visible = false;			screen_introduction.visible = false;			screen_settings.visible = false;			screen_faqs.visible = false;			screen_news.visible = false;			_scroll = false;			trace(">>>>>"+event.dataObj);			switch(event.dataObj){				case "nameselection" :					screen_name_selection.visible = true;					break;				case "classselection" :					screen_class_selection.visible = true;					break;				case "introduction" :					screen_introduction.visible = true;					break;				case "firstQuest" :					screen_first_quest.visible = true;					break;				case "homeScreen" :					screen_home.visible = true;					t = screen_home;_scroll = true;					break;				case "trainingScreen" :					m.loadTrainingXML();					navigation.visible = true;					stats_mc.visible = true;					screen_training.visible = true;					screen_training.y = 0;					t = screen_training;_scroll = true;					break;				case "arenaScreen" :					screen_arena.visible = true;					t = screen_arena;_scroll = true;					break;				case "armoryScreenWeapons" :					m.loadArmoryXML();					screen_armory_weapons.visible = true;					screen_armory_weapons.y = 0;					t = screen_armory_weapons;_scroll = true;					break;				case "armoryScreenArmor" :					m.loadArmoryXML();					screen_armory_armor.visible = true;					screen_armory_armor.y = 0;					t = screen_armory_armor;_scroll = true;					break;				case "collegiumScreen" :					screen_collegium.visible = true;					break;				case "followersScreen" :					screen_followers.visible = true;					break;				case "medicScreen" :					screen_medic.visible = true;					break;				case "coffersScreen" :					screen_coffers.visible = true;					break;				case "profileScreenStat" :					screen_profile_stat.visible = true;					break;				case "profileScreenComments" :					screen_profile_comments.visible = true;					break;				case "profileScreenEquip" :					screen_profile_equip.visible = true;					break;				case "settingsScreen" :					screen_settings.visible = true;					break;				case "faqsScreen" :					screen_faqs.visible = true;					break;				case "emporerScreen" :					screen_emporer.visible = true;					break;				default : break;			}		}				/*			SCROLLING FOR THE SCREENS IS CONTROLLED HERE!		*/		private function setupScrolling():void{			//t = pixel;			Multitouch.inputMode = MultitouchInputMode.GESTURE;        	stage.addEventListener(TransformGestureEvent.GESTURE_PAN, onPan);        	stage.addEventListener(MouseEvent.MOUSE_DOWN, onStartDrag);        	stage.addEventListener(MouseEvent.MOUSE_MOVE, onMoveDrag);        	stage.addEventListener(MouseEvent.MOUSE_UP, onStopDrag);		}				private function onPan(e:TransformGestureEvent):void {        	// Move target display object by equivalent offset from pan object			trace("Panning");			if(!_scroll)				return;				        	t.y += e.offsetY;    	}   	 	private function onStartDrag(e:MouseEvent):void {        	// Start timer to differentiate between click and drag        	_lastMouseEvent = getTimer();        	_dragging = true;        	// Set drag location values to track how drag is occuring        	_prevY = e.stageY;     	}     	private function onMoveDrag(e:MouseEvent):void {         	// If mouse down for less than minimum time, don't drag			if(!_scroll)				return;			         	if (getTimer() > _lastMouseEvent + MIN_DRAG_TIME && _dragging) {             	// Move target display object to a valid location - prevents scrolling too far           		// t.y = ValidYDragPosition(e);				//trace(t.y);								t.y -= (_prevY - e.stageY);				if(t.y < (435 - t.height)){					t.y = 435 - t.height;				}				if(t.y > 0){					//stop screen from going above 0 Y					t.y = 0;				}            	_prevY = e.stageY;         	}     	}     	private function onStopDrag(e:MouseEvent):void {         	_dragging = false;         	// If mouse down time was less than min time, count as click         	if (getTimer() <= _lastMouseEvent + MIN_DRAG_TIME) {             	onClick(e);         	}     	}     	private function onClick(e:MouseEvent):void {         	// Handle your click event here...			trace("onClick fired");			//trace(t.y);     	}     	private function ValidYDragPosition(e:MouseEvent):Number {         	// Get the requested drag amount         	var requestedPoint:Number = _prevY - e.stageY;			//trace(">"+requestedPoint+"    "+_prevY+"/"+e.stageY);         	if (t.y - requestedPoint > 0) {             	// If drag will move target too far down, stop at top of object				//trace(">> 1");             	return 0;         	} else if (t.y - requestedPoint < stage.stageHeight - t.height) {             	// If drag will move target too far up, stop at bottom of object				//trace(">> 2");             	return stage.stageHeight - t.height;         	} else {             	// Otherwise, allow drag by requested amount				//trace(">> 3");             	return t.y - requestedPoint*1.5;         	}     	}	}	}